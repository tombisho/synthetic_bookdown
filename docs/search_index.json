[["index.html", "dsSynthetic: A DataSHIELD package to generate synthetic data Chapter 1 Prerequisites", " dsSynthetic: A DataSHIELD package to generate synthetic data Tom Bishop, Soumya Banerjee 2021-07-28 Chapter 1 Prerequisites This is a book written to provide a tutorial for the dsSynthetic DataSHIELD R package To use it you will need a working version of R with the DataSHIELD cl "],["intro.html", "Chapter 2 Introduction 2.1 Assumptions 2.2 Motivation 2.3 Hypothesis for using synthetic data 2.4 Overview of steps 2.5 Prerequisites", " Chapter 2 Introduction 2.1 Assumptions It is assumed that the reader is familiar with the basic concepts and motivations around using DataSHIELD for federated analysis. More information about this can be found here. Knowledge of R. For harmonisation, knowledge of JavaScript and or MagmaScript is needed. For analysis, an understanding of DSLite. (TO DO add some more links to helpful stuff here) 2.2 Motivation The benefits of the federated approach are that data can be harmonised and analysed without giving complete access to or transferring the data. A less desirable consequence of this approach is that it is more challenging for data experts to harmonise data to common standards, and for analysts to run their scripts, when the data are not tangibly in front of them. One could say that it is like trying to build a Lego model while wearing a blindfold. With harmonisation, some groups have been through the process of transferring and centralising the data, but this negates one of the benefits of the federated approach. While it is only necessary for the harmonisation team to receive the data, a lot of bureaucracy is required. Others have mandated that each group harmonise their own data. The challenge with this approach is that there can be inconsistencies in the approach of different teams, and each team needs training and expertise in the harmonisation process. Analysis via DataSHIELD has no such compromises and requires the analyst to make their own checks to validate that their analysis is progressing as planned. For example, to confirm that a subset into male and female groups has been successful, the analyst could ask for a summary of the original gender column and check the counts of male and female participants match the length of the subset dataframes. These extra steps are fine, but it can be more tricky to confirm the behaviour of more complex functions such as ds.lexis and ds.reshape. 2.3 Hypothesis for using synthetic data R packages like synthpop (Nowok, Raab, and Dibben 2016) have been developed to generate realistic synthetic data that is not disclosive. A dsSynthpop package could be used to generate a synthetic data set on the client side by running the generation on the server side. Users can then perform harmonisation while working with full access to synthetic data on the client to confirm algorithms are working as expected. When the user is happy that the algorithms are working correctly, they can then be applied to the real data on the server side. The user therefore has the benefit of being able to see the data they are working with, but without the need to go through labourious data transfer processes. The same benefits are realised for an analysis user. Other packages that provide synthetic data generation are simstudy and gcipdr. Simstudy requires the user to define the characteristics of variables and their relationships. However, access via DataSHIELD can help provide these summary statistics. There is also the benefit that the user then has precise control over the nature of the synthetic data generated. Likewise, gcipdr makes it easy for users to extract features such as mean, standard deviation and correlations via DataSHIELD, and use these to provide a more automated generation of the synthetic data. 2.4 Overview of steps The hypothesis can be described by the following steps for harmonisation: The data custodian uploads the raw data to the server side and installs the server side pack dsSynthetic The user install the package dsSyntheticClient on the client side The user calls functions in the dsSyntheticClient package to generate a synthetic but non-disclosive data set which is returned to the client side. With the synthetic data on the client side, the user can view the data and build harmonisation algorithms. They will be able to see the results of the algorithms for each row of data. When the algorithms are complete, they can be implemented on Opal using the real data. And for analysis: Assuming steps #1 and #2 above are complete, the user calls functions in the dsSyntheticClient package to generate a synthetic but non-disclosive data set which is returned to the client side. With the synthetic data on the client side, the user then starts a DSLite instance and places the synthetic data into it. The user can then write their analysis using DataSHIELD commands against the DSLite instance. DSLite then allows the user to return any object on the server side. Therefore users can see the results of each step of their script for each row of data. When the analysis script is complete, the user can run it against the real data on the server side. 2.5 Prerequisites Using DataSHIELD also requires some R packages to be installed on the client site. So far, the following R packages must be installed (in their development version): install.packages(&quot;DSOpal&quot;, dependencies = TRUE) install.packages(&quot;dsBaseClient&quot;, repos = c(&quot;https://cloud.r-project.org&quot;, &quot;https://cran.obiba.org&quot;), dependencies = TRUE) devtools::install_github(&quot;tombisho/dsSyntheticClient&quot;, dependencies = TRUE) install.packages(&quot;simstudy&quot;) The package dependencies are then loaded as follows: library(DSOpal) ## Loading required package: opalr ## Loading required package: httr ## Loading required package: DSI ## Loading required package: progress ## Loading required package: R6 library(dsSyntheticClient) References "],["synthpop.html", "Chapter 3 Generating data using synthpop methods", " Chapter 3 Generating data using synthpop methods In this chapter we will look at how to generate synthetic data on the server side using DataSHIELD functions, based on synthpop functionality. First we need to build a login object for the server that holds the data: builder &lt;- DSI::newDSLoginBuilder() # hide credentials builder$append(server=&quot;server1&quot;, url=&quot;https://opal-sandbox.mrc-epid.cam.ac.uk&quot;, user=&quot;dsuser&quot;, password=&quot;password&quot;, table = &quot;DASIM.DASIM1&quot;) logindata &lt;- builder$build() And then we establish a connection to the server: library(DSOpal) if(exists(&quot;connections&quot;)){ datashield.logout(conns = connections) } connections &lt;- datashield.login(logins=logindata, assign = TRUE) ## ## Logging into the collaborating servers ## ## No variables have been specified. ## All the variables in the table ## (the whole dataset) will be assigned to R! ## ## Assigning table data... The first option is to generate a synthetic dataset using an implementation of the synthpop package on the server side. synthpop requires some thought on the part of the user: if you have a data set with a large number of columns it may take a large amount of time to generate the synthetic data. Assuming we have a data set with a small number of columns (i.e. around 10) we can simply execute the following command: library(dsSyntheticClient) library(dsBaseClient) synth_data = ds.syn(data = &quot;D&quot;, method = &quot;cart&quot;, m = 1, seed = 123)$server1$syn We then have the synthetic data on the client side and can view and manipulate it as required: head(synth_data) ## LAB_TSC LAB_TRIG LAB_HDL LAB_GLUC_FASTING PM_BMI_CONTINUOUS DIS_CVA ## 1009 4.320998 0.9221068 1.932509 4.588154 24.25248 0 ## 1012 7.932947 3.4311492 1.231556 4.234590 37.27944 0 ## 1013 6.465673 2.3991640 1.384120 4.385473 38.09126 0 ## 1014 7.055100 1.1889880 1.935859 3.722485 23.25954 0 ## 1015 5.247587 1.8073161 1.283847 5.615076 28.56968 0 ## 1016 7.443416 3.0247684 1.652697 5.540567 30.72788 0 ## DIS_DIAB DIS_AMI GENDER PM_BMI_CATEGORICAL ## 1009 0 0 1 1 ## 1012 0 0 1 3 ## 1013 0 0 0 3 ## 1014 0 0 0 1 ## 1015 0 0 0 2 ## 1016 0 0 0 3 If you have a dataset with a larger number of columns, you could generate a synthetic dataset for a subset of the variables that you need to generate a particular harmonised variable. For example if we needed to generate a diabetes variable based on blood triglycerides, HDL and glucose we could just generate a dataset for those variables: ds.subset(x = &quot;D&quot;, subset = &quot;D2&quot;, cols = c(&quot;LAB_HDL&quot;, &quot;LAB_TRIG&quot;, &quot;LAB_GLUC_FASTING&quot;)) ## Warning: &#39;ds.subset&#39; is deprecated. ## Use &#39;ds.dataFrameSubset&#39; instead. ## See help(&quot;Deprecated&quot;) synth_data_sub = ds.syn(data = &quot;D2&quot;, method = &quot;cart&quot;, m = 1, seed = 123)$server1$syn head(synth_data_sub) ## LAB_HDL LAB_TRIG LAB_GLUC_FASTING ## 1009 1.7714508 0.7221808 5.638771 ## 1012 0.9774569 1.5153916 6.209230 ## 1013 0.9881049 3.1658461 5.350550 ## 1014 2.0103355 -0.3515943 3.331889 ## 1015 1.9042037 -0.2851747 4.988254 ## 1016 1.2544094 1.2883607 3.967962 Lastly we save our data for later chapters: write.csv(x = synth_data, file = &quot;data/synth_data.csv&quot;) "],["methods.html", "Chapter 4 Methods", " Chapter 4 Methods We describe our methods in this chapter. "],["generating-data-using-simstudy-methods.html", "Chapter 5 Generating data using simstudy methods", " Chapter 5 Generating data using simstudy methods In this chapter we will look at how to generate synthetic data on the client side using DataSHIELD functions to extract characteristics of the data set from the server side. Again we need to build a login object for the server that holds the data: builder &lt;- DSI::newDSLoginBuilder() # hide credentials builder$append(server=&quot;server1&quot;, url=&quot;https://opal-sandbox.mrc-epid.cam.ac.uk&quot;, user=&quot;dsuser&quot;, password=&quot;password&quot;, table = &quot;DASIM.DASIM1&quot;) logindata &lt;- builder$build() And then we establish a connection to the server: library(DSOpal) if(exists(&quot;connections&quot;)){ datashield.logout(conns = connections) } connections &lt;- datashield.login(logins=logindata, assign = TRUE) ## ## Logging into the collaborating servers ## ## No variables have been specified. ## All the variables in the table ## (the whole dataset) will be assigned to R! ## ## Assigning table data... This method builds on the fundamentals of the simstudy package. There is a good introduction to this package here. First we load the library library(&quot;simstudy&quot;) library(&quot;dsBaseClient&quot;) Then we can extract some parameters from the real data using DataSHIELD commands and use these to generate our synthetic data. We will look at the binary variables first, and get the probabilities for 0/1: factor_vars = c(&quot;DIS_CVA&quot;, &quot;DIS_DIAB&quot;, &quot;DIS_AMI&quot; ) probs = numeric() for(var in factor_vars){ ds.asNumeric(paste0(&quot;D$&quot;,var), newobj = paste0(var,&quot;_num&quot;), datasources = connections) probs = c(probs, ds.mean(paste0(var,&quot;_num&quot;), datasources = connections)$Mean.by.Study[1]) } Now we use simstudy to generate the binary variables: def &lt;- defData(varname = &quot;GENDER&quot;, dist = &quot;binary&quot;, formula = &quot;0.5&quot;) def &lt;- defData(def, varname = &quot;DIS_CVA&quot;, dist = &quot;binary&quot;, formula = probs[1]) def &lt;- defData(def, varname = &quot;DIS_DIAB&quot;, dist = &quot;binary&quot;, formula = probs[2]) def &lt;- defData(def, varname = &quot;DIS_AMI&quot;, dist = &quot;binary&quot;, formula = probs[3]) synth_data_sim &lt;- genData(1000, def) There are some variables that we expect to be normally distributed, so we will extract the mean and standard deviation: columns = c(&quot;LAB_TSC&quot;, &quot;LAB_TRIG&quot;, &quot;LAB_HDL&quot;, &quot;LAB_GLUC_FASTING&quot;, &quot;PM_BMI_CONTINUOUS&quot;) means = numeric() sds = numeric() for (var in columns){ means = c(means, ds.mean(paste0(&quot;D$&quot;,var), datasources = connections)$Mean.by.Study[1]) sds = c(sds, ds.var(paste0(&quot;D$&quot;,var), datasources = connections)$Variance.by.Study[1]^0.5) } We can obtain the correlation matrix from DataSHIELD: corrs = ds.cor(x=&quot;D&quot;, datasources = connections)[[1]]$`Correlation Matrix` Dnames = ds.colnames(&quot;D&quot;)$server1 colnames(corrs) &lt;- Dnames rownames(corrs) &lt;- Dnames And use the correlation matrix and the properties of the normally distributed data to generate simulated data for them, adding this to the binary data we already generated: synth_data_sim &lt;- addCorData(synth_data_sim, idname = &quot;id&quot;, mu = means, sigma = sds, corMatrix = corrs[c(1:5), c(1:5)], cnames = columns) head(synth_data_sim) ## id GENDER DIS_CVA DIS_DIAB DIS_AMI LAB_TSC LAB_TRIG LAB_HDL ## 1: 1 0 0 0 0 6.487816 2.939696 1.8085709 ## 2: 2 0 0 0 0 6.572320 1.177547 1.6476178 ## 3: 3 1 0 0 0 4.639590 2.521190 1.4719942 ## 4: 4 0 0 0 0 6.874953 4.589414 0.9989147 ## 5: 5 1 0 0 0 5.255427 1.393983 1.5635178 ## 6: 6 1 0 0 0 4.601389 1.397964 1.3029052 ## LAB_GLUC_FASTING PM_BMI_CONTINUOUS ## 1: 3.875665 27.16045 ## 2: 4.417573 25.54674 ## 3: 2.693822 23.57053 ## 4: 6.138792 30.18844 ## 5: 4.503395 23.57939 ## 6: 4.436538 29.14956 TO DO the binary data and normal data are not linked through the correlation. I wonder how this could be done to improve the realism of the data. "],["generating-data-using-gcipdr-methods.html", "Chapter 6 Generating data using gcipdr methods", " Chapter 6 Generating data using gcipdr methods In this chapter we will look at how to generate synthetic data on the client side using DataSHIELD functions to extract characteristics of the data set from the server side. The gcipdr package is an initial version and more details can be found here. More prerequisites: library(devtools) ## Loading required package: usethis install_github(&quot;bonorico/gcipdr&quot;) ## Skipping install of &#39;gcipdr&#39; from a github remote, the SHA1 (59fc74f6) has not changed since last install. ## Use `force = TRUE` to force installation url &lt;- &quot;https://cran.r-project.org/src/contrib/Archive/JohnsonDistribution/JohnsonDistribution_0.24.tar.gz&quot; pkgFile &lt;- &quot;JohnsonDistribution_0.24.tar.gz&quot; download.file(url = url, destfile = pkgFile) install.packages(pkgs=pkgFile, type=&quot;source&quot;, repos=NULL) ## Installing package into &#39;/home/vagrant/R/x86_64-pc-linux-gnu-library/4.0&#39; ## (as &#39;lib&#39; is unspecified) unlink(pkgFile) Again we need to build a login object for the server that holds the data: builder &lt;- DSI::newDSLoginBuilder() # hide credentials builder$append(server=&quot;server1&quot;, url=&quot;https://opal-sandbox.mrc-epid.cam.ac.uk&quot;, user=&quot;dsuser&quot;, password=&quot;password&quot;, table = &quot;DASIM.DASIM1&quot;) logindata &lt;- builder$build() And then we establish a connection to the server: library(DSOpal) if(exists(&quot;connections&quot;)){ datashield.logout(conns = connections) } connections &lt;- datashield.login(logins=logindata, assign = TRUE) ## ## Logging into the collaborating servers ## ## No variables have been specified. ## All the variables in the table ## (the whole dataset) will be assigned to R! ## ## Assigning table data... "],["harmonisation-with-synthetic-data.html", "Chapter 7 Harmonisation with synthetic data 7.1 Getting set up 7.2 Do the work", " Chapter 7 Harmonisation with synthetic data In this section we describe how to harmonise synthetic data on the client side. This assumes that you have used one of the previous methods to generate your synthetic data set. Recall that we are aiming to use synthetic data on the client side to design harmonisation algorithms, and then implement these on Opal on the server side using the real data. This removes the need for the user to have full access to the data. Harmonisation algorithms can be implemented in Opal using MagmaScript (JavaScript) without having full access to the data. The idea is that writing JavaScript on the client side, having full access to the synthetic data, is easier than writing the code on the server side with only access to summaries. In detail, the steps proposed are: Start a JavaScript session on the client side Load the synthetic data into the session Write and test JavaScript code in the session against the synthetic data When happy, copy the code into Opal to generate the harmonised data 7.1 Getting set up First some system level packages may need to be installed: On Debian / Ubuntu install either libv8-dev or libnode-dev, on Fedora use v8-devel. install.packages(&quot;V8&quot;) ## Installing package into &#39;/home/vagrant/R/x86_64-pc-linux-gnu-library/4.0&#39; ## (as &#39;lib&#39; is unspecified) library(&quot;V8&quot;) ## Using V8 engine 6.8.275.32-node.12 7.2 Do the work Now we can start a JavaScript session and load the additional MagmaScript functionality: ct2 = v8() ct2$source(&quot;https://raw.githubusercontent.com/tombisho/dsSyntheticClient/main/MagmaScript.min.js&quot;) ## [1] &quot;true&quot; synth_data = read.csv(file = &quot;data/synth_data.csv&quot;) ct2$assign(&quot;synth_data&quot;, synth_data) We then go into the console, grab a row of data and write some JavaScript: ct2$console() var $ = MagmaScript.MagmaScript.$.bind(als_syn[0]); if ($(&#39;y3age&#39;).value() &gt; 25 ){ out = 1 } else { out = 0 } Now we test our code against the whole dataset: myScript = ` if ($(&#39;y3age&#39;).value() &gt; 25 ){ out = 1 } else { out = 0 } ` var my_out = []; for (j = 0; j &lt; als_syn.length; j++){ my_out.push(MagmaScript.evaluator(myScript, als_syn[j])) } exit And pull the results into R for inspection: my_out = ct2$get(&quot;my_out&quot;) synth_data_harm = synth_data synth_data_harm$my_var = my_out If we are happy with the code, we can paste it directly into the Opal script interface so that it can be executed on the real data. "],["analysis-with-synthetic-data.html", "Chapter 8 Analysis with synthetic data 8.1 Getting set up 8.2 Create synthetic dataset 8.3 Start DSLite local instance", " Chapter 8 Analysis with synthetic data In this section we describe how we can use a copy of the synthetic data to help users write DataSHIELD analysis code. Again we will make use of an existing dataset (** TO DO would be better to run this on some harmonised data) Recall that the objective here is to use a synthetic copy of already harmonised real data that is then made available to the analyst on the client side. This synthetic data set can be loaded into DSLite, a special client side implementation of server side DataSHIELD used for development purposes: the user can have full access to the data. This is acceptable in this situation as the data are synthetic. Therefore the user has the chance to write DataSHIELD code but see the complete results of each step. This makes it easier to develop the code. 8.1 Getting set up We require DSLite and dsBase to be installed: install.packages(&quot;DSLite&quot;, dependencies = TRUE) ## Installing package into &#39;/home/vagrant/R/x86_64-pc-linux-gnu-library/4.0&#39; ## (as &#39;lib&#39; is unspecified) install.packages(&quot;dsBase&quot;, repos = c(&quot;https://cloud.r-project.org&quot;, &quot;https://cran.obiba.org&quot;), dependencies = TRUE) ## Installing package into &#39;/home/vagrant/R/x86_64-pc-linux-gnu-library/4.0&#39; ## (as &#39;lib&#39; is unspecified) Let us assume that the DASIM1 dataset has previously been harmonised and is held on a server. We do not have access to the full dataset but want to do some analysis on it. Using the method described above, the first thing to do is generate a synthetic version that we can fully access. To do this we will use the same steps that were shown in (???)(synthpop) 8.2 Create synthetic dataset We build our log in object builder &lt;- DSI::newDSLoginBuilder() builder$append(server=&quot;server1&quot;, url=&quot;https://opal-sandbox.mrc-epid.cam.ac.uk&quot;, user=&quot;dsuser&quot;, password=&quot;password&quot;, table = &quot;DASIM.DASIM1&quot;) logindata &lt;- builder$build() Then perform the log in to ther server: library(DSOpal) if(exists(&quot;connections&quot;)){ datashield.logout(conns = connections) } connections &lt;- datashield.login(logins=logindata, assign = TRUE) ## ## Logging into the collaborating servers ## ## No variables have been specified. ## All the variables in the table ## (the whole dataset) will be assigned to R! ## ## Assigning table data... The DASIM1 dataset is relatively small (i.e. around 10 columns). This is probably also true of many harmonised data sets. Therefore we can just create a synthetic version of it: library(dsSyntheticClient) synth_data = ds.syn(data = &quot;D&quot;, method = &quot;cart&quot;, m = 1, seed = 123) DASIM = synth_data$server1$syn 8.3 Start DSLite local instance library(DSLite) library(dsBaseClient) dslite.server &lt;- newDSLiteServer(tables=list(DASIM=DASIM)) dslite.server$config(defaultDSConfiguration(include=c(&quot;dsBase&quot;, &quot;dsSynthetic&quot;))) builder &lt;- DSI::newDSLoginBuilder() builder$append(server=&quot;server1&quot;, url=&quot;dslite.server&quot;, table = &quot;DASIM&quot;, driver = &quot;DSLiteDriver&quot;) logindata &lt;- builder$build() if(exists(&quot;connections&quot;)){ datashield.logout(conns = connections) } connections &lt;- datashield.login(logins=logindata, assign = TRUE) ## ## Logging into the collaborating servers ## ## No variables have been specified. ## All the variables in the table ## (the whole dataset) will be assigned to R! ## ## Assigning table data... We can now check for ourselves that our DASIM data is in the DSLite server: ds.summary(&#39;D&#39;) ## $server1 ## $server1$class ## [1] &quot;data.frame&quot; ## ## $server1$`number of rows` ## [1] 10000 ## ## $server1$`number of columns` ## [1] 10 ## ## $server1$`variables held` ## [1] &quot;LAB_TSC&quot; &quot;LAB_TRIG&quot; &quot;LAB_HDL&quot; ## [4] &quot;LAB_GLUC_FASTING&quot; &quot;PM_BMI_CONTINUOUS&quot; &quot;DIS_CVA&quot; ## [7] &quot;DIS_DIAB&quot; &quot;DIS_AMI&quot; &quot;GENDER&quot; ## [10] &quot;PM_BMI_CATEGORICAL&quot; Now suppose we want to subset the DASIM data into men and women. We can use the ds.subset function: ds.subset(x=&quot;D&quot;, subset = &quot;women&quot;, logicalOperator = &quot;==&quot;, threshold = 1) With DSLite we have the chance to look at actually what happened in detail: women = getDSLiteData(conns = connections, symbol = &quot;women&quot;)$server1 head(women) ## LAB_TSC LAB_TRIG LAB_HDL LAB_GLUC_FASTING PM_BMI_CONTINUOUS DIS_CVA ## 1009 4.320998 0.9221068 1.932509 4.588154 24.25248 0 ## 1012 7.932947 3.4311492 1.231556 4.234590 37.27944 0 ## 1013 6.465673 2.3991640 1.384120 4.385473 38.09126 0 ## 1014 7.055100 1.1889880 1.935859 3.722485 23.25954 0 ## 1015 5.247587 1.8073161 1.283847 5.615076 28.56968 0 ## 1016 7.443416 3.0247684 1.652697 5.540567 30.72788 0 ## DIS_DIAB DIS_AMI GENDER PM_BMI_CATEGORICAL ## 1009 0 0 1 1 ## 1012 0 0 1 3 ## 1013 0 0 0 3 ## 1014 0 0 0 1 ## 1015 0 0 0 2 ## 1016 0 0 0 3 This doesn’t look quite right. There are still rows with GENDER == 0. There is an error in our code (we didn’t specify GENDER as part of the logicalOperator parameter) but didn’t get a warning. Let’s make a correction and try again: ds.subset(x=&quot;D&quot;, subset = &quot;women&quot;, logicalOperator = &quot;GENDER==&quot;, threshold = 1) # get the data again women = getDSLiteData(conns = connections, symbol = &quot;women&quot;)$server1 head(women) ## LAB_TSC LAB_TRIG LAB_HDL LAB_GLUC_FASTING PM_BMI_CONTINUOUS DIS_CVA ## 1009 4.320998 0.9221068 1.932509 4.588154 24.25248 0 ## 1012 7.932947 3.4311492 1.231556 4.234590 37.27944 0 ## 1022 4.530228 2.7351977 1.129350 5.454553 29.99532 0 ## 1025 5.026717 1.3289150 1.312407 6.304016 31.75667 0 ## 1026 4.901544 2.3027582 1.569712 4.529539 24.64352 0 ## 1030 5.428203 0.2307445 1.865315 4.039755 34.83133 0 ## DIS_DIAB DIS_AMI GENDER PM_BMI_CATEGORICAL ## 1009 0 0 1 1 ## 1012 0 0 1 3 ## 1022 0 0 1 2 ## 1025 0 0 1 3 ## 1026 0 0 1 1 ## 1030 0 0 1 3 This now looks much better. We can also compare results obtained via DataSHIELD with results on the actual data: from_server = ds.glm(formula = &quot;DIS_DIAB~PM_BMI_CONTINUOUS+LAB_TSC+LAB_HDL&quot;, data = &quot;women&quot;, family = &quot;binomial&quot;) ## Warning: glm.fit: algorithm did not converge ## Warning: glm.fit: algorithm did not converge ## Warning: glm.fit: algorithm did not converge ## Warning: glm.fit: algorithm did not converge ## Warning: glm.fit: algorithm did not converge ## Warning: glm.fit: algorithm did not converge ## Warning: glm.fit: algorithm did not converge ## Warning: glm.fit: algorithm did not converge ## Warning: glm.fit: algorithm did not converge from_local = glm(formula = &quot;DIS_DIAB~PM_BMI_CONTINUOUS+LAB_TSC+LAB_HDL&quot;, data = women, family = &quot;binomial&quot;) from_server$coefficients ## Estimate Std. Error z-value p-value low0.95CI.LP ## (Intercept) -4.37857657 1.10156871 -3.9748556 7.042197e-05 -6.537611563 ## PM_BMI_CONTINUOUS 0.05579333 0.02645985 2.1086038 3.497879e-02 0.003932988 ## LAB_TSC -0.09108649 0.11089084 -0.8214068 4.114146e-01 -0.308428551 ## LAB_HDL -0.51522675 0.33679076 -1.5298126 1.260631e-01 -1.175324504 ## high0.95CI.LP P_OR low0.95CI.P_OR high0.95CI.P_OR ## (Intercept) -2.2195416 0.01238782 0.001445849 0.09800932 ## PM_BMI_CONTINUOUS 0.1076537 1.05737913 1.003940732 1.11366199 ## LAB_TSC 0.1262556 0.91293874 0.734600437 1.13457209 ## LAB_HDL 0.1448710 0.59736512 0.308718783 1.15589045 from_local$coefficients ## (Intercept) PM_BMI_CONTINUOUS LAB_TSC LAB_HDL ## -4.37857657 0.05579333 -0.09108649 -0.51522675 TO DO make a more realistic example for example with ds.lexis or ds.reshape where it is much harder to know what is going on "],["references.html", "References", " References "]]
