[["index.html", "dsSynthetic: A DataSHIELD package to generate synthetic data Chapter 1 Prerequisites", " dsSynthetic: A DataSHIELD package to generate synthetic data Tom Bishop, Soumya Banerjee 2021-08-03 Chapter 1 Prerequisites This is a book written to provide a tutorial for the dsSynthetic DataSHIELD R package To use it you will need a working version of R with the DataSHIELD client packages installed. See 2 for more details. "],["intro.html", "Chapter 2 Introduction 2.1 Assumptions 2.2 Motivation 2.3 Hypothesis for using synthetic data 2.4 Overview of steps 2.5 Prerequisites", " Chapter 2 Introduction 2.1 Assumptions It is assumed that the reader is familiar with the basic concepts and motivations around using DataSHIELD for federated analysis. More information about this can be found here. Knowledge of R. For harmonisation, knowledge of JavaScript and or MagmaScript is needed. For analysis, an understanding of DSLite. (TO DO add some more links to helpful stuff here) 2.2 Motivation The benefits of the federated approach are that data can be harmonised and analysed without giving complete access to or transferring the data. A less desirable consequence of this approach is that it is more challenging for data experts to harmonise data to common standards, and for analysts to run their scripts, when the data are not tangibly in front of them. One could say that it is like trying to build a Lego model while wearing a blindfold. With harmonisation, some groups have been through the process of transferring and centralising the data, but this negates one of the benefits of the federated approach. While it is only necessary for the harmonisation team to receive the data, a lot of bureaucracy is required. Others have mandated that each group harmonise their own data. The challenge with this approach is that there can be inconsistencies in the approach of different teams, and each team needs training and expertise in the harmonisation process. Analysis via DataSHIELD has no such compromises and requires the analyst to make their own checks to validate that their analysis is progressing as planned. This has to be done via non-disclosive information about the data that the analysis has generated. For example, to confirm that a subset into male and female groups has been successful, the analyst could ask for a summary of the original gender column and check the counts of male and female participants match the length of the subset dataframes. These extra steps are fine, but it can be more tricky to confirm the behaviour of more complex functions such as ds.lexis and ds.reshape. 2.3 Hypothesis for using synthetic data R packages like synthpop (Nowok, Raab, and Dibben 2016) have been developed to generate realistic synthetic data that is not disclosive. A dsSynthpop package could be used to generate a synthetic data set on the client side by running the generation on the server side. Users can then perform harmonisation while working with full access to synthetic data on the client to confirm algorithms are working as expected. When the user is happy that the algorithms are working correctly, they can then be applied to the real data on the server side. The user therefore has the benefit of being able to see the data they are working with, but without the need to go through labourious data transfer processes. The same benefits are realised for an analysis user. Other packages that provide synthetic data generation are simstudy and gcipdr. Simstudy requires the user to define the characteristics of variables and their relationships. However, non-disclosive access via DataSHIELD can help provide these summary statistics. There is also the benefit that the user then has precise control over the nature of the synthetic data generated. Likewise, gcipdr makes it easy for users to extract features such as mean, standard deviation and correlations via DataSHIELD, and use these to provide a more automated generation of the synthetic data. In dsSynthetic we provide functionality built on simstudy as it is more mature, has less complex dependencies and is faster. The compromise is that gcipdr should provide more accurate results, as it was designed to provide synthetic data that would allow actual inferences to be drawn as from the real data. However for our purposes we only want synthetic data that is realistic enough to write harmonisation code and plan analysis code: this work is then applied to the real data to get the inferences. 2.4 Overview of steps The hypothesis can be described by the following steps for harmonisation: The data custodian uploads the raw data to the server side and installs the server side pack dsSynthetic The user install the package dsSyntheticClient on the client side The user calls functions in the dsSyntheticClient package to generate a synthetic but non-disclosive data set which is returned to the client side. With the synthetic data on the client side, the user can view the data and build harmonisation algorithms. They will be able to see the results of the algorithms for each row of data. When the algorithms are complete, they can be implemented on Opal using the real data. Figure 2.1: Central harmonisation via synthetic data without full access And for analysis: Assuming steps #1 and #2 above are complete, the user calls functions in the dsSyntheticClient package to generate a synthetic but non-disclosive data set which is returned to the client side. With the synthetic data on the client side, the user then starts a DSLite instance and places the synthetic data into it. The user can then write their analysis using DataSHIELD commands against the DSLite instance. DSLite then allows the user to return any object on the server side. Therefore users can see the results of each step of their script for each row of data. When the analysis script is complete, the user can run it against the real data on the server side. Figure 2.2: Prototyping DataSHIELD analysis using synthetic data on DSLite 2.5 Prerequisites Using DataSHIELD also requires some R packages to be installed on the client site. So far, the following R packages must be installed (in their development version): install.packages(&quot;DSOpal&quot;, dependencies = TRUE) install.packages(&quot;dsBaseClient&quot;, repos = c(&quot;https://cloud.r-project.org&quot;, &quot;https://cran.obiba.org&quot;), dependencies = TRUE) devtools::install_github(&quot;tombisho/dsSyntheticClient&quot;, dependencies = TRUE) install.packages(&quot;simstudy&quot;) The package dependencies are then loaded as follows: library(DSOpal) ## Loading required package: opalr ## Loading required package: httr ## Loading required package: DSI ## Loading required package: progress ## Loading required package: R6 library(dsSyntheticClient) References "],["synthpop.html", "Chapter 3 Generating data using synthpop methods", " Chapter 3 Generating data using synthpop methods In this chapter we will look at how to generate synthetic data on the server side using DataSHIELD functions, based on synthpop functionality. First we need to build a login object for the server that holds the data: builder &lt;- DSI::newDSLoginBuilder() # hide credentials builder$append(server=&quot;server1&quot;, url=&quot;https://opal-sandbox.mrc-epid.cam.ac.uk&quot;, user=&quot;dsuser&quot;, password=&quot;password&quot;, table = &quot;DASIM.DASIM1&quot;) logindata &lt;- builder$build() And then we establish a connection to the server: library(DSOpal) if(exists(&quot;connections&quot;)){ datashield.logout(conns = connections) } connections &lt;- datashield.login(logins=logindata, assign = TRUE) ## ## Logging into the collaborating servers ## ## No variables have been specified. ## All the variables in the table ## (the whole dataset) will be assigned to R! ## ## Assigning table data... The first option is to generate a synthetic dataset using an implementation of the synthpop package on the server side. synthpop requires some thought on the part of the user: if you have a data set with a large number of columns it may take a large amount of time to generate the synthetic data. Assuming we have a data set with a small number of columns (i.e. around 10) we can simply execute the following command: library(dsSyntheticClient) library(dsBaseClient) synth_data = ds.syn(data = &quot;D&quot;, method = &quot;cart&quot;, m = 1, seed = 123)$server1$syn We then have the synthetic data on the client side and can view and manipulate it as required: head(synth_data) ## LAB_TSC LAB_TRIG LAB_HDL LAB_GLUC_FASTING PM_BMI_CONTINUOUS DIS_CVA ## 1013 5.939322 0.4123825 2.5331337 4.780652 16.56022 0 ## 1001 4.488742 1.4545074 1.1666774 4.354192 29.37608 0 ## 1002 5.530095 1.4927338 1.2354929 4.144381 27.20650 0 ## 1003 6.223834 2.7842252 1.4955468 2.751385 22.57965 0 ## 1004 6.249578 3.4324239 0.9035903 4.379078 32.29457 0 ## 1005 2.615003 0.3251287 1.7154251 3.953342 24.67133 0 ## DIS_DIAB DIS_AMI GENDER PM_BMI_CATEGORICAL ## 1013 0 0 1 1 ## 1001 0 0 0 2 ## 1002 0 0 1 2 ## 1003 0 0 0 1 ## 1004 0 0 1 3 ## 1005 0 0 1 1 If you have a dataset with a larger number of columns, you could generate a synthetic dataset for a subset of the variables that you need to generate a particular harmonised variable. For example if we needed to generate a diabetes variable based on blood triglycerides, HDL and glucose we could just generate a dataset for those variables: ds.subset(x = &quot;D&quot;, subset = &quot;D2&quot;, cols = c(&quot;LAB_HDL&quot;, &quot;LAB_TRIG&quot;, &quot;LAB_GLUC_FASTING&quot;)) synth_data_sub = ds.syn(data = &quot;D2&quot;, method = &quot;cart&quot;, m = 1, seed = 123)$server1$syn head(synth_data_sub) ## LAB_HDL LAB_TRIG LAB_GLUC_FASTING ## 1013 1.830697 1.0700770 3.696904 ## 1001 1.017168 2.2473066 3.626215 ## 1002 1.560354 2.5917701 4.229809 ## 1003 1.257052 3.2711980 3.941001 ## 1004 1.636933 0.3509866 4.419090 ## 1005 1.454375 2.3146460 4.580741 Lastly we save our data for later chapters: write.csv(x = synth_data, file = &quot;data/synth_data.csv&quot;) "],["generating-data-using-simstudy-methods.html", "Chapter 4 Generating data using simstudy methods", " Chapter 4 Generating data using simstudy methods In this chapter we will look at how to generate synthetic data on the client side using DataSHIELD functions to extract summary characteristics of the data set from the server side. Again we need to build a login object for the server that holds the data: builder &lt;- DSI::newDSLoginBuilder() # hide credentials builder$append(server=&quot;server1&quot;, url=&quot;https://opal-sandbox.mrc-epid.cam.ac.uk&quot;, user=&quot;dsuser&quot;, password=&quot;password&quot;, table = &quot;DASIM.DASIM1&quot;) logindata &lt;- builder$build() And then we establish a connection to the server: library(DSOpal) if(exists(&quot;connections&quot;)){ datashield.logout(conns = connections) } connections &lt;- datashield.login(logins=logindata, assign = TRUE) ## ## Logging into the collaborating servers ## ## No variables have been specified. ## All the variables in the table ## (the whole dataset) will be assigned to R! ## ## Assigning table data... This method builds on the fundamentals of the simstudy package. There is a good introduction to this package here. First we load the library library(&quot;simstudy&quot;) library(&quot;dsBaseClient&quot;) Then we can extract some parameters from the real data using DataSHIELD commands and use these to generate our synthetic data. We first need some preparatory steps. Binary factor variables are converted to numeric to allow calculation of the probability of 0/1. We remove the factor variables from the data frame, and re-add them after conversion to numeric. Note that if categorical variables are in the data set, they will need to broken down into binary dummy variables before they can be used. cont_vars = c(&quot;LAB_TSC&quot;, &quot;LAB_TRIG&quot;, &quot;LAB_HDL&quot;, &quot;LAB_GLUC_FASTING&quot;, &quot;PM_BMI_CONTINUOUS&quot;) ds.subset(x=&#39;D&#39;, subset=&#39;subD2&#39;, cols=cont_vars) factor_vars = c(&quot;DIS_CVA&quot;, &quot;DIS_DIAB&quot;, &quot;DIS_AMI&quot;) for(var in factor_vars){ ds.asNumeric(paste0(&quot;D$&quot;,var), newobj = paste0(var,&quot;_num&quot;), datasources = connections) ds.dataFrame(x=c(&quot;subD2&quot;, paste0(var,&quot;_num&quot;)), newobj = &quot;subD2&quot;) } Dnames = ds.colnames(&quot;subD2&quot;)$server1 Now we use ds.cor() to generate a correlation matrix. Similarly, ds.mean() and ds.var() are used to obtain the means and variances: TO DO the previous part and this part can be rolled up and done with a helper function like we already prototyped for gcipdr. That is, you pass in the name of a dataframe (or a dataframe and a list of columns?) and it automatically does the categorical -&gt; binary -&gt; numeric, gets the corr matrix, means and vars, and generates the data set, recombines the binaries into categorical where applicable corrs = ds.cor(x=&quot;subD2&quot;, datasources = connections)[[1]]$`Correlation Matrix` colnames(corrs) &lt;- Dnames rownames(corrs) &lt;- Dnames means = numeric() vars = numeric() for (var in Dnames){ means = c(means, ds.mean(paste0(&quot;subD2$&quot;,var), datasources = connections)$Mean.by.Study[1]) vars = c(vars, ds.var(paste0(&quot;subD2$&quot;,var), datasources = connections)$Variance.by.Study[1]) } Once we have the summary information, we use it to build a simstudy definition table. This is then used to generate the synthetic data. def &lt;- defData(varname = &quot;LAB_TSC&quot;, formula = means[1], variance = vars[1], dist = &quot;normal&quot;) for (i in 2:length(cont_vars)){ def &lt;- defData(def, varname = cont_vars[i], formula = means[i], variance = vars[i], dist = &quot;normal&quot;) } for (i in 1:length(factor_vars)){ def &lt;- defData(def, varname = factor_vars[i], formula = means[length(cont_vars)+i], dist = &quot;binary&quot;) } dd &lt;- genCorFlex(10000, def, rho = NULL, tau = NULL, corMatrix = corrs) head(dd) ## id LAB_TSC LAB_TRIG LAB_HDL LAB_GLUC_FASTING PM_BMI_CONTINUOUS DIS_CVA ## 1: 1 5.061832 1.764900 1.631207 4.229844 18.43103 0 ## 2: 2 7.197848 1.792050 1.618762 4.802709 29.55680 0 ## 3: 3 5.840460 4.049302 1.687452 5.016152 34.53278 0 ## 4: 4 6.871120 1.988825 1.605039 4.044210 33.33789 0 ## 5: 5 5.263524 2.142466 1.249333 5.481163 26.41777 0 ## 6: 6 4.939404 0.240306 1.811101 2.680227 23.40127 0 ## DIS_DIAB DIS_AMI ## 1: 0 0 ## 2: 0 0 ## 3: 0 0 ## 4: 0 0 ## 5: 0 0 ## 6: 0 0 While it is most desirable to generate the data in this way, in some situations there might be a reason to generate variables without worrying about their correlation to the other variables. In this case standard simstudy functions could be used. For example, we might need an AGE variable and are not able to include it in the steps illustrated above. We could simply add this variable as follows: def2 &lt;- defData(varname = &quot;AGE&quot;, formula = 40, variance = 10, dist = &quot;normal&quot;) dd &lt;- addColumns(def2, dd) head(dd) ## id LAB_TSC LAB_TRIG LAB_HDL LAB_GLUC_FASTING PM_BMI_CONTINUOUS DIS_CVA ## 1: 1 5.061832 1.764900 1.631207 4.229844 18.43103 0 ## 2: 2 7.197848 1.792050 1.618762 4.802709 29.55680 0 ## 3: 3 5.840460 4.049302 1.687452 5.016152 34.53278 0 ## 4: 4 6.871120 1.988825 1.605039 4.044210 33.33789 0 ## 5: 5 5.263524 2.142466 1.249333 5.481163 26.41777 0 ## 6: 6 4.939404 0.240306 1.811101 2.680227 23.40127 0 ## DIS_DIAB DIS_AMI AGE ## 1: 0 0 34.97744 ## 2: 0 0 35.67096 ## 3: 0 0 41.22921 ## 4: 0 0 41.76373 ## 5: 0 0 39.09275 ## 6: 0 0 38.46279 "],["harmonisation-with-synthetic-data.html", "Chapter 5 Harmonisation with synthetic data 5.1 Getting set up 5.2 Do the work", " Chapter 5 Harmonisation with synthetic data In this section we describe how to harmonise synthetic data on the client side. This assumes that you have used one of the previous methods to generate your synthetic data set. Recall that we are aiming to use synthetic data on the client side to design harmonisation algorithms, and then implement these on Opal on the server side using the real data. This removes the need for the user to have full access to the data. Harmonisation algorithms can be implemented in Opal using MagmaScript (JavaScript) without having full access to the data. The idea is that writing JavaScript on the client side, having full access to the synthetic data, is easier than writing the code on the server side with only access to summaries. In detail, the steps proposed are: Start a JavaScript session on the client side Load the synthetic data into the session Write and test JavaScript code in the session against the synthetic data When happy, copy the code into Opal to generate the harmonised data 5.1 Getting set up First some system level packages may need to be installed: On Debian / Ubuntu install either libv8-dev or libnode-dev, on Fedora use v8-devel. install.packages(&quot;V8&quot;) ## Installing package into &#39;/home/vagrant/R/x86_64-pc-linux-gnu-library/4.0&#39; ## (as &#39;lib&#39; is unspecified) library(&quot;V8&quot;) ## Using V8 engine 6.8.275.32-node.12 5.2 Do the work Now we can start a JavaScript session and load the additional MagmaScript functionality: ct2 = v8() ct2$source(&quot;https://raw.githubusercontent.com/tombisho/dsSyntheticClient/main/MagmaScript.min.js&quot;) ## [1] &quot;true&quot; synth_data = read.csv(file = &quot;data/synth_data.csv&quot;) ct2$assign(&quot;synth_data&quot;, synth_data) We then go into the console, grab a row of data and write some JavaScript: ct2$console() var $ = MagmaScript.MagmaScript.$.bind(als_syn[0]); if ($(&#39;y3age&#39;).value() &gt; 25 ){ out = 1 } else { out = 0 } Now we test our code against the whole dataset: myScript = ` if ($(&#39;y3age&#39;).value() &gt; 25 ){ out = 1 } else { out = 0 } ` var my_out = []; for (j = 0; j &lt; als_syn.length; j++){ my_out.push(MagmaScript.evaluator(myScript, als_syn[j])) } exit And pull the results into R for inspection: my_out = ct2$get(&quot;my_out&quot;) synth_data_harm = synth_data synth_data_harm$my_var = my_out If we are happy with the code, we can paste it directly into the Opal script interface so that it can be executed on the real data. "],["analysis-with-synthetic-data.html", "Chapter 6 Analysis with synthetic data 6.1 Getting set up 6.2 Create synthetic dataset 6.3 Start DSLite local instance", " Chapter 6 Analysis with synthetic data In this section we describe how we can use a copy of the synthetic data to help users write DataSHIELD analysis code. Again we will make use of an existing dataset (** TO DO would be better to run this on some harmonised data) Recall that the objective here is to use a synthetic copy of already harmonised real data that is then made available to the analyst on the client side. This synthetic data set can be loaded into DSLite, a special client side implementation of server side DataSHIELD used for development purposes: the user can have full access to the data. This is acceptable in this situation as the data are synthetic. Therefore the user has the chance to write DataSHIELD code but see the complete results of each step. This makes it easier to develop the code. 6.1 Getting set up We require DSLite and dsBase to be installed: install.packages(&quot;DSLite&quot;, dependencies = TRUE) ## Installing package into &#39;/home/vagrant/R/x86_64-pc-linux-gnu-library/4.0&#39; ## (as &#39;lib&#39; is unspecified) install.packages(&quot;dsBase&quot;, repos = c(&quot;https://cloud.r-project.org&quot;, &quot;https://cran.obiba.org&quot;), dependencies = TRUE) ## Installing package into &#39;/home/vagrant/R/x86_64-pc-linux-gnu-library/4.0&#39; ## (as &#39;lib&#39; is unspecified) Let us assume that the DASIM1 dataset has previously been harmonised and is held on a server. We do not have access to the full dataset but want to do some analysis on it. Using the method described above, the first thing to do is generate a synthetic version that we can fully access. To do this we will use the same steps that were shown in 3 6.2 Create synthetic dataset We build our log in object builder &lt;- DSI::newDSLoginBuilder() builder$append(server=&quot;server1&quot;, url=&quot;https://opal-sandbox.mrc-epid.cam.ac.uk&quot;, user=&quot;dsuser&quot;, password=&quot;password&quot;, table = &quot;DASIM.DASIM1&quot;) logindata &lt;- builder$build() Then perform the log in to ther server: library(DSOpal) if(exists(&quot;connections&quot;)){ datashield.logout(conns = connections) } connections &lt;- datashield.login(logins=logindata, assign = TRUE) ## ## Logging into the collaborating servers ## ## No variables have been specified. ## All the variables in the table ## (the whole dataset) will be assigned to R! ## ## Assigning table data... The DASIM1 dataset is relatively small (i.e. around 10 columns). This is probably also true of many harmonised data sets. Therefore we can just create a synthetic version of it: library(dsSyntheticClient) synth_data = ds.syn(data = &quot;D&quot;, method = &quot;cart&quot;, m = 1, seed = 123) DASIM = synth_data$server1$syn 6.3 Start DSLite local instance library(DSLite) library(dsBaseClient) dslite.server &lt;- newDSLiteServer(tables=list(DASIM=DASIM)) dslite.server$config(defaultDSConfiguration(include=c(&quot;dsBase&quot;, &quot;dsSynthetic&quot;))) builder &lt;- DSI::newDSLoginBuilder() builder$append(server=&quot;server1&quot;, url=&quot;dslite.server&quot;, table = &quot;DASIM&quot;, driver = &quot;DSLiteDriver&quot;) logindata &lt;- builder$build() if(exists(&quot;connections&quot;)){ datashield.logout(conns = connections) } connections &lt;- datashield.login(logins=logindata, assign = TRUE) ## ## Logging into the collaborating servers ## ## No variables have been specified. ## All the variables in the table ## (the whole dataset) will be assigned to R! ## ## Assigning table data... We can now check for ourselves that our DASIM data is in the DSLite server: ds.summary(&#39;D&#39;) ## $server1 ## $server1$class ## [1] &quot;data.frame&quot; ## ## $server1$`number of rows` ## [1] 10000 ## ## $server1$`number of columns` ## [1] 10 ## ## $server1$`variables held` ## [1] &quot;LAB_TSC&quot; &quot;LAB_TRIG&quot; &quot;LAB_HDL&quot; ## [4] &quot;LAB_GLUC_FASTING&quot; &quot;PM_BMI_CONTINUOUS&quot; &quot;DIS_CVA&quot; ## [7] &quot;DIS_DIAB&quot; &quot;DIS_AMI&quot; &quot;GENDER&quot; ## [10] &quot;PM_BMI_CATEGORICAL&quot; Now suppose we want to subset the DASIM data into men and women. We can use the ds.subset function: ds.subset(x=&quot;D&quot;, subset = &quot;women&quot;, logicalOperator = &quot;==&quot;, threshold = 1) With DSLite we have the chance to look at actually what happened in detail: women = getDSLiteData(conns = connections, symbol = &quot;women&quot;)$server1 head(women) ## LAB_TSC LAB_TRIG LAB_HDL LAB_GLUC_FASTING PM_BMI_CONTINUOUS DIS_CVA ## 1013 5.939322 0.4123825 2.5331337 4.780652 16.56022 0 ## 1001 4.488742 1.4545074 1.1666774 4.354192 29.37608 0 ## 1002 5.530095 1.4927338 1.2354929 4.144381 27.20650 0 ## 1003 6.223834 2.7842252 1.4955468 2.751385 22.57965 0 ## 1004 6.249578 3.4324239 0.9035903 4.379078 32.29457 0 ## 1005 2.615003 0.3251287 1.7154251 3.953342 24.67133 0 ## DIS_DIAB DIS_AMI GENDER PM_BMI_CATEGORICAL ## 1013 0 0 1 1 ## 1001 0 0 0 2 ## 1002 0 0 1 2 ## 1003 0 0 0 1 ## 1004 0 0 1 3 ## 1005 0 0 1 1 This doesn’t look quite right. There are still rows with GENDER == 0. There is an error in our code (we didn’t specify GENDER as part of the logicalOperator parameter) but didn’t get a warning. Let’s make a correction and try again: ds.subset(x=&quot;D&quot;, subset = &quot;women&quot;, logicalOperator = &quot;GENDER==&quot;, threshold = 1) # get the data again women = getDSLiteData(conns = connections, symbol = &quot;women&quot;)$server1 head(women) ## LAB_TSC LAB_TRIG LAB_HDL LAB_GLUC_FASTING PM_BMI_CONTINUOUS DIS_CVA ## 1013 5.939322 0.4123825 2.5331337 4.780652 16.56022 0 ## 1002 5.530095 1.4927338 1.2354929 4.144381 27.20650 0 ## 1004 6.249578 3.4324239 0.9035903 4.379078 32.29457 0 ## 1005 2.615003 0.3251287 1.7154251 3.953342 24.67133 0 ## 1010 5.189675 1.5872435 1.7576039 3.502300 30.10351 0 ## 2301 6.401451 2.8097121 1.4876340 4.964355 28.72204 0 ## DIS_DIAB DIS_AMI GENDER PM_BMI_CATEGORICAL ## 1013 0 0 1 1 ## 1002 0 0 1 2 ## 1004 0 0 1 3 ## 1005 0 0 1 1 ## 1010 0 0 1 3 ## 2301 0 0 1 2 This now looks much better. We can also compare results obtained via DataSHIELD with results on the actual data: from_server = ds.glm(formula = &quot;DIS_DIAB~PM_BMI_CONTINUOUS+LAB_TSC+LAB_HDL&quot;, data = &quot;women&quot;, family = &quot;binomial&quot;) ## Warning: glm.fit: algorithm did not converge ## Warning: glm.fit: algorithm did not converge ## Warning: glm.fit: algorithm did not converge ## Warning: glm.fit: algorithm did not converge ## Warning: glm.fit: algorithm did not converge ## Warning: glm.fit: algorithm did not converge ## Warning: glm.fit: algorithm did not converge ## Warning: glm.fit: algorithm did not converge ## Warning: glm.fit: algorithm did not converge ## Warning: glm.fit: algorithm did not converge from_local = glm(formula = &quot;DIS_DIAB~PM_BMI_CONTINUOUS+LAB_TSC+LAB_HDL&quot;, data = women, family = &quot;binomial&quot;) from_server$coefficients ## Estimate Std. Error z-value p-value low0.95CI.LP ## (Intercept) -6.0430125 1.07150306 -5.639753 1.702944e-08 -8.14311987 ## PM_BMI_CONTINUOUS 0.1439233 0.02563643 5.614015 1.976845e-08 0.09367683 ## LAB_TSC -0.2203753 0.10708899 -2.057871 3.960252e-02 -0.43026590 ## LAB_HDL -0.5597964 0.31679551 -1.767059 7.721835e-02 -1.18070413 ## high0.95CI.LP P_OR low0.95CI.P_OR high0.95CI.P_OR ## (Intercept) -3.94290507 0.002368771 0.0002906442 0.01902291 ## PM_BMI_CONTINUOUS 0.19416978 1.154795539 1.0982047814 1.21430243 ## LAB_TSC -0.01048477 0.802217643 0.6503361470 0.98957001 ## LAB_HDL 0.06111143 0.571325401 0.3070624495 1.06301736 from_local$coefficients ## (Intercept) PM_BMI_CONTINUOUS LAB_TSC LAB_HDL ## -6.0430125 0.1439233 -0.2203753 -0.5597964 TO DO make a more realistic example for example with ds.lexis or ds.reshape where it is much harder to know what is going on "],["references.html", "References", " References "]]
